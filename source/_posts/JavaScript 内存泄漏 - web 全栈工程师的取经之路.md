---
title: JavaScript 内存泄漏 - web 全栈工程师的取经之路
---
内存泄漏简介
======

内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃。

垃圾回收机制
======

最常使用的方法叫做 "引用计数"（reference counting）：语言引擎有一张 "引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。

```
const arr = [1, 2, 3, 4];
console.log('hello world');

```

上面代码中，数组 [1, 2, 3, 4] 是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1。尽管后面的代码没有用到 arr，它还是会持续占用内存。

```
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;

```

上面代码中，arr 重置为 null，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0，内存就可以释放出来了。

内存泄漏的识别方法
=========

经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。

浏览器识别
-----

Chrome 浏览器查看内存占用，按照以下步骤操作。

![](https://segmentfault.com/img/remote/1460000016720119?w=720&h=313)

![](https://segmentfault.com/img/remote/1460000016720120?w=1442&h=766)

1.  打开开发者工具，选择 Timeline 面板
2.  在顶部的 Capture 字段里面勾选 Memory
3.  点击左上角的录制按钮。
4.  在页面上进行各种操作，模拟用户的使用情况。
5.  一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。

如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。

命令行识别
-----

命令行可以使用 Node 提供的 process.memoryUsage 方法。

```
console.log(process.memoryUsage());
// { rss: 27709440,
//  heapTotal: 5685248,
//  heapUsed: 3449392,
//  external: 8772 }

```

process.memoryUsage 返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。

![](https://segmentfault.com/img/remote/1460000016720121)

*   rss（resident set size）：所有内存占用，包括指令区和堆栈。
*   heapTotal："堆" 占用的内存，包括用到的和没用到的。
*   heapUsed：用到的堆的部分。
*   external： V8 引擎内部的 C++ 对象占用的内存。

判断内存泄漏，以 heapUsed 字段为准。

WeakSet 和 WeakMap
=================

前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。

最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。

ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个 "Weak"，表示这是弱引用。详细具体看阮一峰的 ECMAScript 6 入门。